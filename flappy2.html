<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flappy Denis — I LOVE DENIS Edition</title>
<style>
  html, body { height:100%; margin:0; background:#fdeff4; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;}
  canvas { display:block; margin:0 auto; background:linear-gradient(#fff7fb, #ffeef5); }
  .hint {
    position:fixed; left:50%; transform:translateX(-50%);
    bottom:10px; color:#b06b83; font-weight:600; font-size:14px; opacity:.85;
    background:#ffffffaa; border:1px solid #ffd1e1; border-radius:999px; padding:6px 12px;
    user-select:none
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hint">Nhấn Space / Click / Chạm để nhảy • Nhấn R để chơi lại</div>
<script>
(() => {
  // ===== Canvas setup & resize =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function resize() {
    const scale = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width  = Math.floor(window.innerWidth  * scale);
    canvas.height = Math.floor(window.innerHeight * scale);
    canvas.style.width  = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ===== Game constants tuned to feel like original =====
  const G = 0.5;            // gravity
  const FLAP_VY = -8.5;     // jump impulse
  const PIPE_SPEED = 2.2;   // pipe horizontal speed
  const PIPE_GAP = 130;     // vertical gap
  const PIPE_W = 68;        // pipe width
  const PIPE_SPACING = 200; // horizontal distance between pipes
  const SPAWN_EVERY = 90;   // frames between spawns (roughly)
  const FLOOR = () => Math.floor(canvas.height * 0.85); // virtual ground line
  const SKY = () => Math.floor(canvas.height * 0.10);
  const BIRD_X = () => Math.floor(canvas.width * 0.25);

  // Phrase progress
  const PHRASE = "I LOVE DENIS"; // includes spaces
  const LETTER_SCORE_STEP = 5;

  // ===== Game state =====
  let state = 'menu'; // 'menu' | 'play' | 'over' | 'complete'
  let frame = 0;
  let score = 0;
  let best = 0;
  let pipes = [];
  let particles = [];
  let cherries = [];
  let letterIndex = 0;        // how many letters earned (excluding spaces progression)
  let earnedLetters = [];     // array of {ch, x, y, tx, ty, t, done}
  let fireworks = [];
  let messageTimer = 0;

  // Bird (Chocobo chibi-ish)
  const bird = {
    x: BIRD_X(),
    y: canvas.height/2,
    vy: 0,
    r: Math.max(14, Math.min(24, Math.floor(canvas.height * 0.02))), // radius
  };

  // ===== Input =====
  let justFlapped = false;
  function flap() {
    if (state === 'menu') { reset(); state='play'; }
    if (state === 'play') { bird.vy = FLAP_VY; justFlapped = true; }
    if (state === 'over' || state === 'complete') { reset(); state='play'; }
  }
  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); flap(); }
    if (e.key.toLowerCase() === 'r') { reset(); state='play'; }
  });
  window.addEventListener('mousedown', flap);
  window.addEventListener('touchstart', e => { e.preventDefault(); flap(); }, {passive:false});

  // ===== Helpers =====
  function rand(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // Pastel pipe colors
  const PIPE_COLORS = ['#ffc7d8','#ffd9e6','#e3d9ff','#c9f2ff','#c7ffd9','#fff0c2'];
  function pastelPipeColor(i){ return PIPE_COLORS[i % PIPE_COLORS.length]; }

  // ===== Background cherries pattern (animated slight float) =====
  function initCherries() {
    const count = Math.floor((canvas.width * canvas.height) / 50000);
    cherries = [];
    for (let i=0;i<count;i++){
      cherries.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        r: rand(6,10) * (canvas.height/800),
        s: rand(0.2,0.6),
        t: Math.random()*Math.PI*2
      });
    }
  }
  initCherries();

  function drawCherry(x,y,r,t){
    // stems
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(Math.sin(t)*0.05);
    ctx.lineWidth = Math.max(1, r*0.15);
    ctx.strokeStyle = '#9fc59e';
    ctx.beginPath();
    ctx.moveTo(-r*0.3, -r*1.1); ctx.quadraticCurveTo(-r*0.6, -r*1.5, 0, -r*1.6); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo( r*0.3, -r*1.1); ctx.quadraticCurveTo( r*0.6, -r*1.5, 0, -r*1.6); ctx.stroke();
    // leaf
    ctx.fillStyle = '#bfe6be';
    ctx.beginPath();
    ctx.ellipse(0, -r*1.45, r*0.6, r*0.28, Math.PI/6, 0, Math.PI*2);
    ctx.fill();
    // cherries
    const c1 = '#ffb3c7', c2 = '#ffc7d8';
    ctx.fillStyle = c1; ctx.beginPath(); ctx.arc(-r*0.45, -r*0.2, r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = c2; ctx.beginPath(); ctx.arc( r*0.45,  -r*0.2, r, 0, Math.PI*2); ctx.fill();
    // highlight
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.beginPath(); ctx.ellipse(-r*0.7, -r*0.5, r*0.3, r*0.18, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // ===== Pipe management =====
  function spawnPipe(){
    const minTop = SKY()+40;
    const maxBottom = FLOOR()-40;
    const totalSpan = maxBottom - minTop - PIPE_GAP;
    const topH = Math.floor(minTop + Math.random()*Math.max(40, totalSpan));
    const bottomY = topH + PIPE_GAP;
    pipes.push({
      x: canvas.width + PIPE_W,
      top: topH,
      bottomY: bottomY,
      scored: false,
      color: pastelPipeColor(Math.floor(Math.random()*1000))
    });
  }

  // ===== Letters animation to top center =====
  function targetSlotPosFor(index) {
    // index over PHRASE non-space letters order
    // We place the phrase centered top, right below SKY(), using letter spacing
    const text = PHRASE;
    ctx.save();
    const baseSize = Math.max(18, Math.floor(canvas.height * 0.03));
    ctx.font = `bold ${baseSize}px system-ui, Segoe UI, Arial`;
    const metrics = ctx.measureText(text);
    const textW = metrics.width;
    const startX = (canvas.width - textW)/2;
    const y = SKY() - baseSize*0.2; // just above top area
    ctx.restore();

    // find visual x of the N-th non-space char
    let nonSpaceIdx = -1;
    let x = startX;
    for (let i=0;i<text.length;i++){
      const ch = text[i];
      const w = ctx.measureText(ch).width;
      if (ch !== ' ') {
        nonSpaceIdx++;
        if (nonSpaceIdx === index) {
          return { x: x + w/2, y: y };
        }
      }
      x += w;
    }
    // fallback
    return {x: canvas.width/2, y: y};
  }

  function launchLetterAnim(ch, fromX, fromY, index){
    const target = targetSlotPosFor(index);
    earnedLetters.push({
      ch, x: fromX, y: fromY, tx: target.x, ty: target.y, t:0, done:false
    });
  }

  // ===== Fireworks on complete =====
  function spawnFirework(x,y){
    const N = 60;
    for (let i=0;i<N;i++){
      const a = (i/N)*Math.PI*2;
      const sp = rand(2.5,5.5);
      fireworks.push({
        x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: rand(40,70),
        color: ['#ff7aa2','#ffd166','#9ad0f5','#c5ffa8','#e7b3ff'][Math.floor(Math.random()*5)]
      });
    }
  }

  // ===== Reset game =====
  function reset(){
    frame = 0; score = 0; pipes = []; particles = []; fireworks = []; messageTimer=0;
    letterIndex = 0; earnedLetters = [];
    bird.x = BIRD_X(); bird.y = canvas.height/2; bird.vy = 0;
  }

  // ===== Collision helper =====
  function circleRectCollide(cx, cy, r, rx, ry, rw, rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx;
    const dy = cy - ny;
    return (dx*dx + dy*dy) <= r*r;
  }

  // ===== Draw chocobo (simple cute) =====
  function drawChocobo(x,y,r, tilt){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(tilt);

    // body
    ctx.fillStyle = '#ffd75a';
    ctx.beginPath();
    ctx.ellipse(0, 0, r*1.1, r*0.9, 0, 0, Math.PI*2);
    ctx.fill();

    // wing
    ctx.fillStyle = '#ffea9e';
    ctx.beginPath();
    ctx.ellipse(-r*0.1, -r*0.1, r*0.7, r*0.45, -0.6, 0, Math.PI*2);
    ctx.fill();

    // head
    ctx.fillStyle = '#ffdd66';
    ctx.beginPath();
    ctx.arc(r*0.9, -r*0.3, r*0.65, 0, Math.PI*2);
    ctx.fill();

    // hair tuft
    ctx.strokeStyle = '#ffcc33';
    ctx.lineWidth = Math.max(1, r*0.12);
    ctx.beginPath(); ctx.moveTo(r*0.9, -r*1.0); ctx.quadraticCurveTo(r*1.2, -r*1.2, r*1.1, -r*0.6); ctx.stroke();

    // beak
    ctx.fillStyle = '#ffac3e';
    ctx.beginPath();
    ctx.moveTo(r*1.35, -r*0.3);
    ctx.lineTo(r*1.75, -r*0.15);
    ctx.lineTo(r*1.35,  -r*0.05);
    ctx.closePath(); ctx.fill();

    // eye
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(r*1.1, -r*0.35, r*0.12, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'white';
    ctx.beginPath(); ctx.arc(r*1.07, -r*0.38, r*0.05, 0, Math.PI*2); ctx.fill();

    // legs
    ctx.strokeStyle = '#e08a3d';
    ctx.lineWidth = Math.max(1, r*0.12);
    ctx.beginPath(); ctx.moveTo(-r*0.1, r*0.7); ctx.lineTo(-r*0.2, r*1.2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo( r*0.1, r*0.7); ctx.lineTo( r*0.0, r*1.2); ctx.stroke();

    // feet
    ctx.strokeStyle = '#e08a3d';
    ctx.lineWidth = Math.max(1, r*0.12);
    ctx.beginPath(); ctx.moveTo(-r*0.2, r*1.2); ctx.lineTo(-r*0.5, r*1.2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo( 0, r*1.2); ctx.lineTo( r*0.3, r*1.2); ctx.stroke();

    ctx.restore();
  }

  // ===== Main loop =====
  function update(){
    frame++;

    // background fill
    ctx.clearRect(0,0,canvas.width, canvas.height);

    // soft sky stripes
    const grad = ctx.createLinearGradient(0,0,0,canvas.height);
    grad.addColorStop(0,'#fff7fb');
    grad.addColorStop(1,'#ffeef5');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // cherries float
    for (const c of cherries){
      c.t += 0.01 + c.s*0.01;
      const yy = c.y + Math.sin(c.t)*2;
      drawCherry(c.x, yy, c.r, c.t);
    }

    // Ground guideline (invisible ground feel)
    // ctx.strokeStyle = '#eee'; ctx.beginPath(); ctx.moveTo(0,FLOOR()); ctx.lineTo(canvas.width, FLOOR()); ctx.stroke();

    // Phrase bar (top)
    drawPhraseBar();

    if (state === 'menu'){
      drawBirdPhysicsPreview();
      drawCenterText("Nhấn để bắt đầu", '#b06b83', 32);
      requestAnimationFrame(update);
      return;
    }

    if (state === 'play'){
      // physics
      bird.vy += G;
      bird.y += bird.vy;
      const tilt = clamp(bird.vy/12, -0.35, 0.45);

      // spawn pipes
      if (frame % SPAWN_EVERY === 0) spawnPipe();

      // move & draw pipes
      let passed = false;
      for (let i=0;i<pipes.length;i++){
        const p = pipes[i];
        p.x -= PIPE_SPEED;

        // draw
        drawPipe(p);

        // score
        if (!p.scored && p.x + PIPE_W < bird.x - bird.r){
          p.scored = true;
          score++;
          // Every +5 score unlocks a letter (skip spaces)
          if (score % LETTER_SCORE_STEP === 0){
            const nextLetter = nextPhraseLetter(letterIndex);
            if (nextLetter) {
              launchLetterAnim(nextLetter, bird.x, bird.y - bird.r*1.2, letterIndex);
              letterIndex++;
              if (!nextPhraseLetter(letterIndex)) {
                // Completed phrase!
                // Delay a hair to let last letter land
                setTimeout(()=> {
                  completeCelebration();
                }, 600);
              }
            }
          }
        }

        // collisions: top pipe and bottom pipe rectangles
        const topRect = {x:p.x, y:0, w:PIPE_W, h:p.top};
        const botRect = {x:p.x, y:p.bottomY, w:PIPE_W, h:canvas.height - p.bottomY};
        if (circleRectCollide(bird.x, bird.y, bird.r, topRect.x, topRect.y, topRect.w, topRect.h) ||
            circleRectCollide(bird.x, bird.y, bird.r, botRect.x, botRect.y, botRect.w, botRect.h)) {
          gameOver();
        }
      }
      // cleanup pipes
      pipes = pipes.filter(p => p.x + PIPE_W > -50);

      // floor/sky bounds
      if (bird.y - bird.r < 0 || bird.y + bird.r > FLOOR()) {
        gameOver();
      }

      // bird
      drawChocobo(bird.x, bird.y, bird.r, tilt);

      // letters anim
      updateLetters();

      // score
      drawScore();

    } else if (state === 'over') {
      // freeze motion lightly show pipes
      for (const p of pipes) drawPipe(p);
      drawChocobo(bird.x, bird.y, bird.r, 0.3);
      updateLetters(true);
      drawScore();
      drawGameOver();

    } else if (state === 'complete') {
      // fireworks show
      for (const p of pipes) drawPipe(p);
      drawChocobo(bird.x, bird.y, bird.r, 0);
      updateLetters(false, true);
      updateFireworks();
      drawScore(true);
      drawWinMessage();
    }

    requestAnimationFrame(update);
  }

  function drawPipe(p){
    // main
    ctx.fillStyle = p.color;
    // top
    ctx.fillRect(p.x, 0, PIPE_W, p.top);
    ctx.fillRect(p.x-6, p.top-20, PIPE_W+12, 20); // cap
    // bottom
    ctx.fillRect(p.x, p.bottomY, PIPE_W, canvas.height - p.bottomY);
    ctx.fillRect(p.x-6, p.bottomY, PIPE_W+12, 20); // cap
    // soft inner shading
    ctx.fillStyle = 'rgba(255,255,255,0.20)';
    ctx.fillRect(p.x+4, 0, 8, p.top);
    ctx.fillRect(p.x+4, p.bottomY, 8, canvas.height - p.bottomY);
  }

  function nextPhraseLetter(idx){
    // returns next non-space char at sequential order of non-space positions, else null
    let n = -1;
    for (let i=0;i<PHRASE.length;i++){
      if (PHRASE[i] !== ' '){
        n++;
        if (n === idx) return PHRASE[i];
      }
    }
    return null;
  }

  function drawPhraseBar(){
    const baseSize = Math.max(18, Math.floor(canvas.height * 0.03));
    const y = SKY();
    ctx.font = `700 ${baseSize}px system-ui, Segoe UI, Arial`;
    // draw assembled text with earned letters filled in
    const text = PHRASE;
    // measure to center
    const totalW = ctx.measureText(text).width;
    const startX = (canvas.width - totalW)/2;

    // background pill
    const padX = 14, padY = 10, rad = 18;
    ctx.save();
    ctx.translate(0, -baseSize*0.8);
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    roundRect(ctx, startX - padX, y - baseSize, totalW + padX*2, baseSize + padY*2, rad);
    ctx.fill();
    ctx.restore();

    // draw characters with fade for locked ones
    let nonSpaceIdx = -1;
    let x = startX;
    for (let i=0;i<text.length;i++){
      const ch = text[i];
      const w = ctx.measureText(ch).width;
      if (ch === ' '){
        ctx.fillStyle = '#c7a2b3';
        ctx.fillText(' ', x, y);
      } else {
        nonSpaceIdx++;
        if (nonSpaceIdx < letterIndex){
          ctx.fillStyle = '#b06b83';
          ctx.fillText(ch, x, y);
        } else {
          ctx.fillStyle = 'rgba(176,107,131,0.25)';
          ctx.fillText(ch, x, y);
        }
      }
      x += w;
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function updateLetters(paused=false, snap=false){
    const baseSize = Math.max(18, Math.floor(canvas.height * 0.03));
    ctx.font = `700 ${baseSize}px system-ui, Segoe UI, Arial`;
    for (const L of earnedLetters){
      if (!L.done){
        if (!paused){
          L.t = Math.min(1, L.t + 0.04);
          if (snap) L.t = 1;
          const ease = (t)=> 1 - Math.pow(1-t, 3);
          const et = ease(L.t);
          L.x = L.x + (L.tx - L.x)*et;
          L.y = L.y + (L.ty - L.y)*et;
          if (L.t >= 1) { L.done = true; L.x = L.tx; L.y = L.ty; }
        }
      }
      ctx.fillStyle = '#b06b83';
      ctx.fillText(L.ch, L.x, L.y);
    }
  }

  function drawScore(muted=false){
    const s = `Score: ${score}`;
    ctx.font = `600 ${Math.max(22, Math.floor(canvas.height*0.035))}px system-ui, Segoe UI, Arial`;
    ctx.fillStyle = muted ? '#caa8b7' : '#b06b83';
    ctx.fillText(s, 20, Math.max(SKY()+30, 40));
    ctx.font = `500 ${Math.max(14, Math.floor(canvas.height*0.02))}px system-ui, Segoe UI, Arial`;
    ctx.fillStyle = '#caa8b7';
    ctx.fillText(`Best: ${best}`, 20, Math.max(SKY()+30, 40) + 22);
  }

  function drawCenterText(text, color='#b06b83', size=28){
    ctx.font = `700 ${Math.max(size, Math.floor(canvas.height*0.04))}px system-ui, Segoe UI, Arial`;
    const metrics = ctx.measureText(text);
    ctx.fillStyle = color;
    ctx.fillText(text, (canvas.width - metrics.width)/2, canvas.height*0.55);
  }

  function drawGameOver(){
    const msg = "YOU DON'T LOVE ME （‿ɣ‿） Ɑ͞ ̶͞ ̶͞ ̶͞ لں͞";
    drawCenterText(msg, '#b06b83', 28);
  }

  function drawWinMessage(){
    const msg = "❤︎ BÉ CƯNG GIỎI LẮM! THƯỞNG NGÀN NỤ HÔN VÀO ... ⸜(｡˃ ᵕ ˂ )⸝♡❤︎";
    // gentle pulsing
    messageTimer++;
    const s = 30 + Math.sin(messageTimer*0.06)*2;
    drawCenterText(msg, '#b06b83', s);
  }

  function completeCelebration(){
    // switch state, spawn fireworks bursts across top
    state = 'complete';
    const y = canvas.height*0.28;
    for (let i=0;i<6;i++){
      const x = (canvas.width/7)*(i+1);
      spawnFirework(x, y + rand(-20,20));
    }
  }

  function updateFireworks(){
    for (let i=fireworks.length-1;i>=0;i--){
      const f = fireworks[i];
      f.x += f.vx;
      f.y += f.vy;
      f.vy += 0.03;
      f.life--;
      ctx.fillStyle = f.color;
      ctx.globalAlpha = Math.max(0, Math.min(1, f.life/60));
      ctx.beginPath(); ctx.arc(f.x, f.y, 2, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      if (f.life<=0) fireworks.splice(i,1);
    }
  }

  function drawBirdPhysicsPreview(){
    // idle float
    const t = frame/30;
    const y = canvas.height*0.5 + Math.sin(t)*10;
    drawChocobo(BIRD_X(), y, bird.r, Math.sin(t)*0.1);
    // hint title
    ctx.font = `800 ${Math.max(26, Math.floor(canvas.height*0.045))}px system-ui, Segoe UI, Arial`;
    const title = "FLAPPY DENIS";
    const m = ctx.measureText(title);
    ctx.fillStyle = '#b06b83';
    ctx.fillText(title, (canvas.width-m.width)/2, canvas.height*0.30);
  }

  function gameOver(){
    if (state !== 'play') return;
    state = 'over';
    best = Math.max(best, score);
  }

  // ===== Start loop =====
  reset();
  requestAnimationFrame(update);

  // Recompute cherries on resize end
  let resizeTimer=null;
  window.addEventListener('resize', ()=>{
    if (resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=>{ initCherries(); bird.x = BIRD_X(); }, 150);
  });

})();
</script>
</body>
</html>
